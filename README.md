# Learn CMake

[CMake](https://cmake.org/) is an open-source, cross-platform build file generator.

## Tutorials

- More Modern CMake
    - <https://hsf-training.github.io/hsf-training-cmake-webpage/index.html>
    - <https://www.youtube.com/watch?v=y7ndUhdQuU8>
- Effective Modern CMake
    - <https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1>
- CGold: The Hitchhikerâ€™s Guide to the CMake
    - <https://cgold.readthedocs.io/en/latest/index.html>
- An Introduction to Modern CMake
    - <https://cliutils.gitlab.io/modern-cmake/>

## Configure

- [CMakeDoc: cmake-generators](https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html)

```
-S <cmake-dir>
-B <build-dir>
-G {"Ninja"|"Ninja Multi-Config"|"Visual Studio 17 2022"|...}
-D<var-name>=<value>
```

```fish
cmake -S . -B build/clang_debug -G "Ninja" -DCMAKE_BUILD_TYPE=Debug -DUSE_SANITIZER:BOOL=ON
```

### compile_commands.json

`set(CMAKE_EXPORT_COMPILE_COMMANDS ON)`

- CMake will generate `compile_commands.json`.
- It only works with make and ninja.
- For clangd create `.clangd` file and set `CompileFlags.CompilationDatabase: <path>`
    ```
    CompileFlags:
      CompilationDatabase: build/       # Search build/ directory for compile_commands.json
    ```

### 32/64bit build

- For **GCC**, **Clang**
    - 32bit: `-m32` (compiler and linker flag)
    - 64bit: `-m64` (compiler and linker flag)
- For **Visual Studio Generator**
    - 32bit: `cmake ... -G ... -A Win32`
    - 64bit: `cmake ... -G ... -A x64`

### Using Ninja generator with MSVC

- <https://stackoverflow.com/a/66467752>

1. Open a developer command prompt.
    - **x64 Native Tools Command Prompt for VS 2022**: Use x64 compiler to compile for a x64 machine
    - **x64_x86 Cross Tools Command Prompt for VS 2022**: Use x64 compiler to compile for a x86 machine
    - **x86 Native Tools Command Prompt for VS 2022**: Use x86 compiler to compile for a x86 machine
    - **x86_x64 Cross Tools Command Prompt for VS 2022**: Use x86 compiler to compile for a x64 machine
2. Configure CMake from the developer command prompt.
    ```fish
    cmake -S . -B build\msvc -G "Ninja Multi-Config"
    ```

> [!NOTE]\
> `compile_commands.json` generated by CMake does not work with **clangd** when configured with **MSVC**.

### Convert MinGW `*.dll.a` to `*.lib`

- [CMakeDock:CMAKE_GNUtoMS](https://cmake.org/cmake/help/latest/variable/CMAKE_GNUtoMS.html)\
    `set(CMAKE_GNUtoMS ON)`

## Build

```fish
cmake --build <build-dir>
    [-j <max-parallel-jobs>]
    [-t <target-name>]
    [--config {Debug|Release|RelWithDebInfo}]
    [-v]
```

## `message`

- [CMakeDoc: message](https://cmake.org/cmake/help/latest/command/message.html)

### General messages

`message([<mode>] "message text" ...)`

Record the specified message text in the log. If more than one message string is given,
they are concatenated into a single message with no separator between the strings. The optional `<mode>` keyword
determines the type of message, which influences the way the message is handled.

- `FATAL_ERROR`
- `SEND_ERROR`
- `WARNING`
- `AUTHOR_WARNING`
- `DEPRECATION`
- `NOTICE` (default)
- `STATUS`
- `VERBOSE`
- `DEBUG`
- `TRACE`

### Reporting checks

A common pattern in CMake output is a message indicating the start of some sort of check, followed by another message reporting the result of that check.

`message(<checkState> "message" ...)`

where `<checkState>` must be one of the following:

- `CHECK_START`\
    Record a concise message about the check about to be performed.
- `CHECK_PASS`\
    Record a successful result for a check.
- `CHECK_FAIL`\
    Record an unsuccessful result for a check.

Checks may be nested and every `CHECK_START` should have exactly one matching `CHECK_PASS` or `CHECK_FAIL`. The `CMAKE_MESSAGE_INDENT` variable can also be used to add indenting to nested checks if desired. For example:
```cmake
message(CHECK_START "Finding my things")
list(APPEND CMAKE_MESSAGE_INDENT "  ")
unset(missingComponents)

message(CHECK_START "Finding partA")
# ... do check, assume we find A
message(CHECK_PASS "found")

message(CHECK_START "Finding partB")
# ... do check, assume we don't find B
list(APPEND missingComponents B)
message(CHECK_FAIL "not found")

list(POP_BACK CMAKE_MESSAGE_INDENT)
if(missingComponents)
  message(CHECK_FAIL "missing components: ${missingComponents}")
else()
  message(CHECK_PASS "all components found")
endif()
```

Output from the above would appear something like the following:
```
-- Finding my things
--   Finding partA
--   Finding partA - found
--   Finding partB
--   Finding partB - not found
-- Finding my things - missing components: B
```

## `target_sources`

- [CMakeDoc: target_sources](https://cmake.org/cmake/help/latest/command/target_sources.html#command:target_sources)

If you provide `BASE_DIRS` for `PUBLIC/INTERFACE` `FILE_SET HEADERS` it will automatically add to include directory.

```cmake
target_sources(some_target
  PRIVATE
    some/source/file.cpp

  INTERFACE
    FILE_SET HEADERS
    BASE_DIRS
      some/include/path
    FILES
      some/include/path/header.hpp
)
```

## `add_library`

- [CMakeDoc: add_library](https://cmake.org/cmake/help/latest/command/add_library.html)

```cmake
add_library(<name> STATIC <sources>...)
add_library(<name> SHARED <sources>...)
add_library(<name> OBJECT <sources>...)
add_library(<name> INTERFACE)
```

## `FetchContent`

- [CMakeDoc: FetchContent](https://cmake.org/cmake/help/latest/module/FetchContent.html)
- <https://www.foonathan.net/2022/06/cmake-fetchcontent/>

## cmake-toolchains

- [CMakeDoc: cmake-toolchains](https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html)
- [Cross Compiling With CMake](https://cmake.org/cmake/help/book/mastering-cmake/chapter/Cross%20Compiling%20With%20CMake.html)

Example of providing a mingw toolchain file to cmake. (cross-compile windows exe in linux)
```cmake
# mingw.cmake

# set target operating to windows
set(CMAKE_SYSTEM_NAME Windows)

# set compiler to mingw
set(CMAKE_C_COMPILER /usr/bin/x86_64-w64-mingw32-gcc)
set(CMAKE_CXX_COMPILER /usr/bin/x86_64-w64-mingw32-g++)
set(CMAKE_RC_COMPILER /usr/bin/x86_64-w64-mingw32-windres)

# where is the target environment located
set(CMAKE_FIND_ROOT_PATH /usr/x86_64-w64-mingw32)

# adjust the default behavior of the FIND_XXX() commands:
# search programs in the host environment
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)

# search headers and libraries in the target environment
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
```

```fish
cmake -S . -B build/mingw -G "Ninja Multi-Config" -DCMAKE_TOOLCHAIN_FILE=~/mingw.cmake
cmake --build build/mingw
```

## cmake-presets

- [CMakeDoc: cmake-presets](https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html)
- <https://martin-fieber.de/blog/cmake-presets/>
- <https://www.youtube.com/watch?v=vKUaWxemtWI>

---

- CMakePresets.json
- CMakeUserPresets.json (add to `.gitignore`)

```fish
# configure
cmake . --list-presets
cmake . --preset 'preset name'
```

```fish
# build
cmake --build --list-presets
cmake --build --preset 'preset name'
```

## cmake-file-api

- [CMakeDoc: cmake-file-api](https://cmake.org/cmake/help/latest/manual/cmake-file-api.7.html)
- [Retrieve build information](https://blog.insane.engineer/post/cmake_build_information/)

## CPM

`CPM.cmake` is a cross-platform CMake script that adds dependency management capabilities to CMake.
It's built as a thin wrapper around CMake's FetchContent module.

- <https://github.com/cpm-cmake/CPM.cmake>
- <https://github.com/cpm-cmake/CPM.cmake/wiki/More-Snippets>
